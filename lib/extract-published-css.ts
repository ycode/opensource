/**
 * Extract Published CSS - Extract compiled CSS from Tailwind JIT iframe
 * 
 * This module creates a temporary hidden iframe with Tailwind JIT CDN,
 * renders all layers, waits for CSS compilation, and extracts the generated styles.
 */

import type { Layer } from '@/types';

/**
 * Extract full CSS from Tailwind JIT by rendering layers in temporary iframe
 * 
 * @param layers - Complete layer tree to render
 * @returns Promise resolving to minified CSS string
 */
export async function extractPublishedCSS(layers: Layer[]): Promise<string> {
  return new Promise((resolve, reject) => {
    
    // Create temporary hidden iframe
    const iframe = document.createElement('iframe');
    iframe.style.position = 'fixed';
    iframe.style.top = '-9999px';
    iframe.style.left = '-9999px';
    iframe.style.width = '1px';
    iframe.style.height = '1px';
    iframe.style.visibility = 'hidden';
    document.body.appendChild(iframe);
    
    const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
    if (!iframeDoc) {
      document.body.removeChild(iframe);
      reject(new Error('Could not access iframe document'));
      return;
    }
    
    // Write HTML with Tailwind CDN
    iframeDoc.open();
    iframeDoc.write(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <script src="https://cdn.tailwindcss.com"></script>
        <script>
          tailwind.config = {
            theme: {
              screens: {
                'max-lg': {'max': '1023px'},
                'max-md': {'max': '767px'},
              },
              extend: {}
            }
          }
        </script>
      </head>
      <body id="extraction-root"></body>
      </html>
    `);
    iframeDoc.close();
    
    // Wait for Tailwind to load and compile
    const checkTailwindLoaded = () => {
      const win = iframe.contentWindow;
      if (!win || !(win as any).tailwind) {
        return false;
      }
      return true;
    };
    
    let attempts = 0;
    const maxAttempts = 50; // 5 seconds max
    
    const waitForTailwind = setInterval(() => {
      attempts++;
      
      if (attempts > maxAttempts) {
        clearInterval(waitForTailwind);
        document.body.removeChild(iframe);
        reject(new Error('Timeout waiting for Tailwind to load'));
        return;
      }
      
      if (!checkTailwindLoaded()) {
        return;
      }
      
      clearInterval(waitForTailwind);
      
      try {
        // Render layers into iframe
        const root = iframeDoc.getElementById('extraction-root');
        if (!root) {
          document.body.removeChild(iframe);
          reject(new Error('Could not find extraction root'));
          return;
        }
        
        root.innerHTML = renderLayersToHTML(layers);
        
        // Wait a bit more for Tailwind JIT to process all classes
        setTimeout(() => {
          try {
            // Extract all <style> tags generated by Tailwind
            const styleTags = iframeDoc.querySelectorAll('style');
            let css = '';
            
            styleTags.forEach(tag => {
              // Skip if it's the tailwind config script
              if (tag.textContent && !tag.textContent.includes('tailwind.config')) {
                css += tag.textContent;
              }
            });
            
            // Minify CSS
            const minifiedCSS = minifyCSS(css);
            
            
            // Cleanup
            document.body.removeChild(iframe);
            
            resolve(minifiedCSS);
          } catch (error) {
            document.body.removeChild(iframe);
            reject(error);
          }
        }, 1000); // Wait 1 second for JIT compilation
      } catch (error) {
        document.body.removeChild(iframe);
        reject(error);
      }
    }, 100); // Check every 100ms
  });
}

/**
 * Render layers to HTML string (recursive)
 */
function renderLayersToHTML(layers: Layer[]): string {
  return layers.map(layer => renderLayerToHTML(layer)).join('');
}

/**
 * Render single layer to HTML string
 */
function renderLayerToHTML(layer: Layer): string {
  // Skip hidden layers
  if (layer.settings?.hidden) {
    return '';
  }
  
  const tag = getHtmlTag(layer);
  const classes = getClassesString(layer);
  const text = getText(layer);
  const customId = layer.settings?.id ? ` id="${escapeHtml(layer.settings.id)}"` : '';
  const classAttr = classes ? ` class="${escapeHtml(classes)}"` : '';
  
  // Handle void elements
  if (tag === 'img') {
    const src = layer.url || '';
    const alt = layer.alt || 'Image';
    return `<img${customId}${classAttr} src="${escapeHtml(src)}" alt="${escapeHtml(alt)}" />`;
  }
  
  if (tag === 'br' || tag === 'hr' || tag === 'input') {
    return `<${tag}${customId}${classAttr} />`;
  }
  
  // Regular elements with children
  let content = '';
  
  if (text) {
    content = escapeHtml(text);
  }
  
  if (layer.children && layer.children.length > 0) {
    content += renderLayersToHTML(layer.children);
  }
  
  return `<${tag}${customId}${classAttr}>${content}</${tag}>`;
}

/**
 * Get HTML tag for layer
 */
function getHtmlTag(layer: Layer): string {
  if (layer.settings?.tag) {
    return layer.settings.tag;
  }
  
  if (layer.name) {
    return layer.name;
  }
  
  switch (layer.type) {
    case 'heading':
      return 'h2';
    case 'text':
      return 'p';
    case 'image':
      return 'img';
    case 'container':
    default:
      return 'div';
  }
}

/**
 * Get classes string from layer
 */
function getClassesString(layer: Layer): string {
  if (Array.isArray(layer.classes)) {
    return layer.classes.join(' ');
  }
  return layer.classes || '';
}

/**
 * Get text content from layer
 */
function getText(layer: Layer): string {
  return layer.text || layer.content || '';
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, char => map[char]);
}

/**
 * Minify CSS - remove comments, extra whitespace, and newlines
 */
function minifyCSS(css: string): string {
  return css
    // Remove comments
    .replace(/\/\*[\s\S]*?\*\//g, '')
    // Remove newlines
    .replace(/\n/g, '')
    // Remove extra spaces
    .replace(/\s+/g, ' ')
    // Remove spaces around { } : ; ,
    .replace(/\s*\{\s*/g, '{')
    .replace(/\s*\}\s*/g, '}')
    .replace(/\s*:\s*/g, ':')
    .replace(/\s*;\s*/g, ';')
    .replace(/\s*,\s*/g, ',')
    // Remove trailing semicolons
    .replace(/;}/g, '}')
    .trim();
}

