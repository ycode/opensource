# Cursor AI Rules - YCode Project

## ğŸ¯ Project Overview
**YCode** is a self-hosted visual website builder. It functions as a normal website, but accessing `/ycode` opens a drag-and-drop visual builder where authenticated users can edit the live website in real-time. Changes are saved to the database and immediately reflected on the public site.

**Key Concept:**
- All routes are public and render dynamically from Supabase content
- **ONLY `/ycode` is protected** - requires authentication via Supabase Auth
- **Layer-based editing** - Figma-style layers with direct Tailwind class editing
- **Draft vs Published** workflow - Autosave drafts, explicit publish action
- **Live preview** - Changes appear instantly in preview iframe
- **CDN caching** - Published pages cached on Vercel CDN with cache invalidation
- **Three-panel editor** - Pages/Layers | Preview Canvas | Tailwind Editor

**Self-Hosted Model:**
- Each YCode installation is **completely independent**
- Users deploy to Vercel and connect their **own Supabase instance**
- First-time setup: Connect Supabase â†’ Auto-migrate â†’ Create admin user
- All user data lives in **their** Supabase (they own it)
- No vendor lock-in, no shared backend, no multi-tenancy

## ğŸ—ï¸ Architecture
- **Frontend**: Next.js 15 + TypeScript + Tailwind CSS + Zustand (SPA)
- **Backend**: Next.js API Routes (interface to Supabase)
- **Credential Storage**: Vercel KV (Redis) - ONLY stores Supabase credentials
- **Database (Remote)**: Supabase (PostgreSQL) - All app data
- **Authentication**: Supabase Auth (JWT tokens)
- **Communication**: Next.js SPA â†’ Next.js API Routes â†’ Supabase
- **Storage**: Pages (with layers as JSON) stored in Supabase, assets in Supabase Storage
- **Deployment**: Vercel with CDN caching + cache tag invalidation on publish
- **First-Run**: Welcome wizard saves credentials to Vercel KV, runs migrations
- **Self-Update**: Version checking against GitHub releases

---

## ğŸš€ First-Time Setup Flow

### **User Journey**
```
1. User clicks "Deploy to Vercel" button
   â†“
2. Vercel deploys YCode â†’ redirects to site
   â†“
3. First visit: "Welcome to YCode" wizard
   â†’ Step 1: Welcome screen (explains setup)
   â†“
4. Step 2: Connect Supabase
   â†’ Enter Supabase Project URL
   â†’ Enter Supabase Anon Key
   â†’ Enter Supabase Service Role Key
   â†’ Enter Vercel API Token (for env var updates)
   â†“
5. YCode validates and configures:
   â†’ Tests Supabase connection
   â†’ Writes env vars to Vercel via API
   â†’ Saves credentials to Vercel KV
   â†’ Triggers Vercel redeploy with new env vars
   â†“
6. Step 3: Run migrations on user's Supabase
   â†’ Create 'pages' table
   â†’ Create 'page_versions' table (draft/published)
   â†’ Create 'assets' table
   â†’ Create 'settings' table
   â†“
7. Step 4: Create admin account
   â†’ Enter email + password
   â†’ YCode â†’ Supabase Auth creates user
   â†’ User authenticated automatically
   â†“
8. Redirect to /ycode builder
   â†’ Three-panel editor ready
   â†’ User can start building pages
```

### **Database Strategy**

| Database | Stores | Why |
|----------|--------|-----|
| **Vercel KV (Redis)** | Supabase credentials only | Secure serverless storage for credentials |
| **Supabase (remote)** | Users, pages, components, settings | User's own database - they own their data |

### **Critical Setup Rules**
- **MUST** validate Supabase credentials before storing
- **MUST** run all migrations on user's Supabase during setup
- **MUST** handle migration errors gracefully (show user-friendly messages)
- **NEVER** store sensitive data in Vercel KV beyond Supabase credentials
- **ALWAYS** store Supabase credentials securely in Vercel KV
- **MUST** create first admin user in Supabase Auth during setup

---

## ğŸ“ File Structure Rules

### **Next.js Structure**
```
next.js/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ page.tsx              # Home page (shows Welcome wizard or renders from DB)
â”‚   â”œâ”€â”€ [slug]/page.tsx       # Dynamic pages (ISR with cache tags)
â”‚   â”œâ”€â”€ welcome/              # First-run setup wizard
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â””â”€â”€ ycode/                # Visual builder interface
â”‚       â”œâ”€â”€ page.tsx          # Three-panel editor layout
â”‚       â””â”€â”€ components/
â”‚           â”œâ”€â”€ LeftSidebar/  # Pages list + Layers tree
â”‚           â”œâ”€â”€ CenterCanvas/ # Preview iframe
â”‚           â””â”€â”€ RightSidebar/ # Tailwind class editor
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                   # Reusable UI components
â”‚   â”œâ”€â”€ layers/               # Layer renderers (Container, Text, Image)
â”‚   â””â”€â”€ builder/              # Builder-specific components
â”œâ”€â”€ stores/                   # Zustand state management
â”‚   â”œâ”€â”€ useEditorStore.ts     # Selected layer, current page
â”‚   â”œâ”€â”€ usePagesStore.ts      # Pages CRUD
â”‚   â””â”€â”€ useLayersStore.ts     # Layers tree state
â”œâ”€â”€ lib/                      # Utilities and API handlers
â”‚   â”œâ”€â”€ api/                  # API client functions
â”‚   â”œâ”€â”€ vercel.ts             # Vercel API integration
â”‚   â””â”€â”€ supabase.ts           # Supabase client
â””â”€â”€ types/                    # TypeScript definitions
```

### **Backend API Structure**
```
next.js/
â”œâ”€â”€ app/api/                  # Next.js API Routes
â”‚   â”œâ”€â”€ setup/
â”‚   â”‚   â”œâ”€â”€ status/route.ts   # Check setup status
â”‚   â”‚   â”œâ”€â”€ connect/route.ts  # Connect Supabase
â”‚   â”‚   â””â”€â”€ migrate/route.ts  # Run migrations
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ route.ts          # GET all pages, POST create
â”‚   â”‚   â”œâ”€â”€ [id]/
â”‚   â”‚   â”‚   â”œâ”€â”€ route.ts      # GET/PUT/DELETE by ID
â”‚   â”‚   â”‚   â”œâ”€â”€ draft/route.ts        # Draft operations
â”‚   â”‚   â”‚   â”œâ”€â”€ publish/route.ts      # Publish page
â”‚   â”‚   â”‚   â””â”€â”€ published/route.ts    # Get published version
â”‚   â”‚   â””â”€â”€ slug/[slug]/route.ts      # Get page by slug
â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”œâ”€â”€ route.ts          # GET all, POST upload
â”‚   â”‚   â””â”€â”€ [id]/route.ts     # DELETE asset
â”‚   â”œâ”€â”€ revalidate/route.ts   # Cache invalidation
â”‚   â””â”€â”€ updates/
â”‚       â””â”€â”€ check/route.ts    # Version checking
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ kv.ts                 # Vercel KV client
â”‚   â”œâ”€â”€ supabase-server.ts    # Supabase client (server-side)
â”‚   â”œâ”€â”€ repositories/         # Data access layer
â”‚   â”‚   â”œâ”€â”€ pageRepository.ts
â”‚   â”‚   â”œâ”€â”€ pageVersionRepository.ts
â”‚   â”‚   â””â”€â”€ assetRepository.ts
â”‚   â””â”€â”€ services/             # Business logic
â”‚       â”œâ”€â”€ migrationService.ts
â”‚       â””â”€â”€ cacheInvalidationService.ts
â””â”€â”€ database/migrations/      # Supabase SQL migrations
    â”œâ”€â”€ 2025_10_14_123226_create_pages_table.sql
    â”œâ”€â”€ 2025_10_14_123227_create_page_versions_table.sql
    â””â”€â”€ 2025_10_14_123228_create_assets_table.sql
```

---

## ğŸ”§ Coding Standards

### **Code Formatting**
- **All Code**: Uses ESLint with Next.js config (`next.js/eslint.config.mjs`)
- Run `npm run lint` for auto-fixes
- Run `npm run type-check` for TypeScript validation

### **TypeScript/JavaScript Style (ESLint)**
- **Indentation**: 2 spaces (enforced by ESLint)
- **Quotes**: Single quotes (with template literals allowed)
- **Object spacing**: Always use spaces in curly braces `{ key: value }`
- **JSX props**: Max 2 props per line, multiline props indented 2 spaces
- **JSX brackets**: Tag-aligned closing brackets
- **Self-closing tags**: Space before `/>`

### **TypeScript Rules**
- **ALWAYS** use proper TypeScript types - NEVER use `any`
- Define interfaces for all data structures
- Use generic types for reusable components
- Prefer type inference over explicit typing when obvious

```typescript
// âœ… REQUIRED - Proper formatting
interface LinkMetadata {
  title: string;
  description: string;
  image?: string;
  url: string;
}

const MyComponent: React.FC = () => {
  const data = { key: 'value' }; // âœ… Spaces in braces

  return (
    <div
      className="container"
      onClick={handleClick}  // âœ… 2 props max per line
    >
      <Button variant="primary" size="lg" />  // âœ… Space before />
    </div>
  );
};

// âŒ FORBIDDEN
const metadata: any = { ... };  // Never use 'any'
const bad={key:'value'};  // Missing spaces, wrong quotes
```

### **React Component Standards**
- **ALWAYS** use functional components with hooks
- **MUST** implement proper loading and error states
- **MUST** use `React.FC<Props>` for component typing
- Use `useCallback` and `useMemo` for performance optimization
- **ALWAYS** handle undefined/null states gracefully

```typescript
// âœ… REQUIRED PATTERN
const LinkCard: React.FC<LinkCardProps> = ({ href, isGridLayout }) => {
  const [metadata, setMetadata] = useState<LinkMetadata | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Always include error handling
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const result = await fetchLinkMetadata(href);
        setMetadata(result);
      } catch (err) {
        setError(getErrorMessage(err));
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [href]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!metadata) return null;

  return (
    // Component JSX
  );
};
```

### **Next.js API Route Standards**
- **ALWAYS** use proper TypeScript types and return types
- **MUST** implement request validation for all endpoints
- **ALWAYS** use Next.js naming conventions (route.ts)
- **MUST** handle errors gracefully with appropriate HTTP status codes

```typescript
// âœ… REQUIRED PATTERN
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    if (!body.slug || !body.title) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Process request
    const result = await pageRepository.create(body);
    return NextResponse.json({ data: result }, { status: 201 });
  } catch (error) {
    console.error('Error:', error);
    return NextResponse.json(
      { error: 'Failed to create page' },
      { status: 500 }
    );
  }
}
```

### **Repository Pattern (CRITICAL)**
- **NEVER** use Supabase client directly in API Routes - ALWAYS use Repositories
- **ALWAYS** use TypeScript types for data transfer
- **MUST** create repository modules for all data access
- **MUST** use server-side Supabase client from `lib/supabase-server.ts`

#### **Architecture Flow:**
```
API Route â†’ Repository â†’ Supabase Client
    â†“            â†“              â†“
  Request    TypeScript    Server-Side
            Interface        Only
```

#### **Required Pattern:**

```typescript
// âœ… CORRECT - Using Repository Pattern

// 1. Create Repository (lib/repositories/pageRepository.ts)
import { getSupabaseServiceRoleClient } from '../supabase-server';
import type { Page } from '../../types';

const TABLE_NAME = 'pages';

export const pageRepository = {
  async getAll(): Promise<Page[]> {
    const supabase = await getSupabaseServiceRoleClient();
    const { data, error } = await supabase
      .from(TABLE_NAME)
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data;
  },

  async getById(id: string): Promise<Page | null> {
    const supabase = await getSupabaseServiceRoleClient();
    const { data, error } = await supabase
      .from(TABLE_NAME)
      .select('*')
      .eq('id', id)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data;
  },

  async getBySlug(slug: string): Promise<Page | null> {
    const supabase = await getSupabaseServiceRoleClient();
    const { data, error } = await supabase
      .from(TABLE_NAME)
      .select('*')
      .eq('slug', slug)
      .single();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data;
  },

  async create(page: Omit<Page, 'id' | 'created_at' | 'updated_at'>): Promise<Page> {
    const supabase = await getSupabaseServiceRoleClient();
    const { data, error } = await supabase
      .from(TABLE_NAME)
      .insert(page)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  async update(id: string, updates: Partial<Omit<Page, 'id' | 'created_at' | 'updated_at'>>): Promise<Page> {
    const supabase = await getSupabaseServiceRoleClient();
    const { data, error } = await supabase
      .from(TABLE_NAME)
      .update(updates)
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  async delete(id: string): Promise<void> {
    const supabase = await getSupabaseServiceRoleClient();
    const { error } = await supabase
      .from(TABLE_NAME)
      .delete()
      .eq('id', id);
    
    if (error) throw error;
  },
};

// 2. Use in API Route (app/api/pages/[id]/route.ts)
import { NextResponse } from 'next/server';
import { pageRepository } from '@/lib/repositories/pageRepository';

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const page = await pageRepository.getById(params.id);
    
    if (!page) {
      return NextResponse.json({ error: 'Page not found' }, { status: 404 });
    }
    
    return NextResponse.json({ data: page });
  } catch (error: any) {
    console.error(`Error fetching page ${params.id}:`, error);
    return NextResponse.json(
      { error: error.message || 'Failed to fetch page' },
      { status: 500 }
    );
  }
}
```

#### **âŒ FORBIDDEN - Direct Supabase in API Routes:**
```typescript
// âŒ BAD - Direct Supabase usage in API Route
import { getSupabaseServiceRoleClient } from '@/lib/supabase-server';

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  // WRONG! Use repository instead
  const supabase = await getSupabaseServiceRoleClient();
  const { error } = await supabase
    .from('pages')
    .delete()
    .eq('id', params.id);
  
  // This breaks the architecture pattern!
}
```

---

## ğŸ—ï¸ Editor & Data Model Requirements

### **Page & Layer Data Structure**
- Pages have **draft** and **published** versions (separate records)
- Layers are nested JSON structures with Tailwind classes
- Autosave updates draft version every 2 seconds (debounced)

```typescript
// âœ… Page Structure
interface Page {
  id: string;
  slug: string;
  title: string;
  status: 'draft' | 'published';
  published_version_id: string | null;  // Reference to published PageVersion
  created_at: string;
  updated_at: string;
}

// âœ… Page Version Structure (draft vs published)
interface PageVersion {
  id: string;
  page_id: string;
  layers: Layer[];      // JSONB column
  is_published: boolean;
  created_at: string;
}

// âœ… Layer Structure (nested tree)
interface Layer {
  id: string;           // Unique ID for React keys
  type: 'container' | 'text' | 'image' | 'heading';
  classes: string;      // Tailwind classes: "flex gap-4 bg-blue-500"
  content?: string;     // For text/heading layers
  src?: string;         // For image layers
  children?: Layer[];   // Nested layers
}
```

### **Draft vs Published Workflow**
```
User edits page in editor
  â†’ Changes autosaved to draft PageVersion (every 2s)
  â†’ Preview shows draft version
  
User clicks "Publish"
  â†’ Copy current draft PageVersion
  â†’ Mark new version as is_published: true
  â†’ Update Page.published_version_id
  â†’ Trigger Vercel cache invalidation
  â†’ Public sees published version
```

### **Three-Panel Editor UI**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Left (20%)     â”‚  Center (60%)   â”‚  Right (20%)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Pages List    â”‚  Preview iframe â”‚  Tailwind Editor â”‚
â”‚   - Home        â”‚                 â”‚                  â”‚
â”‚   - About       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  Selected: div#1 â”‚
â”‚   + New Page    â”‚  â”‚  Website  â”‚  â”‚                  â”‚
â”‚                 â”‚  â”‚  Preview  â”‚  â”‚  Classes:        â”‚
â”‚ â€¢ Layers Tree   â”‚  â”‚           â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â–¡ Container   â”‚  â”‚  [Live]   â”‚  â”‚  â”‚flex gap-4  â”‚  â”‚
â”‚     â–¡ Heading   â”‚  â”‚           â”‚  â”‚  â”‚bg-blue-500 â”‚  â”‚
â”‚     â–¡ Text      â”‚  â”‚           â”‚  â”‚  â”‚p-4 rounded â”‚  â”‚
â”‚     â–¡ Image     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                 â”‚                 â”‚  [Apply]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **API Communication**
- **ALWAYS** use relative URLs for API calls (they're in the same Next.js app)
- **MUST** include Supabase Auth JWT token for authenticated requests to `/ycode` endpoints (future)
- API routes are server-side and use service role client

```typescript
// âœ… REQUIRED - Relative API calls
const response = await fetch('/api/pages', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json',
  }
});

// For authenticated requests (future implementation):
const supabaseToken = supabase.auth.session()?.access_token;

const response = await fetch('/api/pages', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${supabaseToken}`
  },
  body: JSON.stringify({ title: 'New Page', slug: 'new-page' })
});
```

### **Supabase Integration**
- **ALWAYS** use Supabase client for app data (pages, components, etc.)
- **ALWAYS** use Vercel KV for credential storage only
- **NEVER** mix the two - clear separation of concerns
- **MUST** handle case where Supabase is not configured

```typescript
// âœ… REQUIRED - Server-side Supabase client (lib/supabase-server.ts)
import { createClient } from '@supabase/supabase-js';
import { kv } from './kv';

interface SupabaseCredentials {
  url: string;
  anon_key: string;
  service_role_key: string;
}

let cachedSupabaseConfig: SupabaseCredentials | null = null;

export async function getSupabaseConfig(): Promise<SupabaseCredentials | null> {
  if (cachedSupabaseConfig) {
    return cachedSupabaseConfig;
  }

  const config = await kv.get<SupabaseCredentials>('supabase_config');
  if (config) {
    cachedSupabaseConfig = config;
  }
  return config;
}

export async function getSupabaseClient() {
  const config = await getSupabaseConfig();
  if (!config) {
    throw new Error('Supabase not configured');
  }
  return createClient(config.url, config.anon_key);
}

export async function getSupabaseServiceRoleClient() {
  const config = await getSupabaseConfig();
  if (!config) {
    throw new Error('Supabase not configured');
  }
  return createClient(config.url, config.service_role_key);
}

// âœ… REQUIRED - Vercel KV for credential storage (lib/kv.ts)
import { createClient } from '@vercel/kv';

export const kv = createClient({
  url: process.env.KV_REST_API_URL!,
  token: process.env.KV_REST_API_TOKEN!,
});
```

### **Migrations Strategy**
- **Supabase migrations**: Store in `next.js/database/migrations/` directory
- **MUST** run Supabase migrations via direct SQL execution on user's instance during setup
- Migrations are SQL files executed using Supabase's service role client

```typescript
// âœ… REQUIRED - Running Supabase migrations (lib/services/migrationService.ts)
import { getSupabaseServiceRoleClient } from '../supabase-server';
import fs from 'fs/promises';
import path from 'path';

const migrationFiles = [
  '2025_10_14_123226_create_pages_table.sql',
  '2025_10_14_123227_create_page_versions_table.sql',
  '2025_10_14_123228_create_assets_table.sql',
];

export const migrationService = {
  async getMigrationSQL(): Promise<string[]> {
    const migrations: string[] = [];
    for (const file of migrationFiles) {
      const filePath = path.join(process.cwd(), 'next.js/database/migrations', file);
      const sql = await fs.readFile(filePath, 'utf-8');
      migrations.push(sql);
    }
    return migrations;
  },

  async runMigrations(): Promise<void> {
    const supabase = await getSupabaseServiceRoleClient();
    const migrations = await this.getMigrationSQL();

    for (const sql of migrations) {
      // Execute SQL directly on Supabase
      const { error } = await supabase.rpc('exec_sql', { sql });
      if (error) throw error;
    }
  },
};
```

### **CDN & Caching Strategy**
- Public pages use **Next.js ISR** with Vercel CDN caching
- Each page has a **cache tag** based on slug
- Publish action **invalidates cache** via Vercel API

```typescript
// âœ… Dynamic page with cache tags (app/[slug]/page.tsx)
export async function generateStaticParams() {
  const pages = await fetchAllPublishedPages();
  return pages.map(page => ({ slug: page.slug }));
}

export const revalidate = 60; // ISR revalidation

export default async function Page({ params }: { params: { slug: string } }) {
  const page = await fetchPageBySlug(params.slug);
  
  // Add cache tag
  unstable_cache(() => page, [`page-${params.slug}`]);
  
  return <LayerRenderer layers={page.layers} />;
}
```

```php
// âœ… Invalidate cache on publish (Laravel)
protected function invalidateCache(Page $page): void
{
    Http::withToken(config('vercel.token'))
        ->purge('https://api.vercel.com/v1/purge', [
            'tags' => ["page-{$page->slug}"]
        ]);
}
```

### **Vercel Integration**
- First-run setup **writes env vars** to Vercel via API
- Requires **Vercel API token** with write permissions
- Triggers **redeploy** after env vars updated

```php
// âœ… Write env vars to Vercel
class VercelService
{
    public function updateEnvVars(array $vars): void
    {
        $projectId = config('vercel.project_id');
        $token = request()->input('vercel_token');
        
        foreach ($vars as $key => $value) {
            Http::withToken($token)->post(
                "https://api.vercel.com/v10/projects/{$projectId}/env",
                [
                    'key' => $key,
                    'value' => $value,
                    'type' => 'encrypted',
                    'target' => ['production']
                ]
            );
        }
        
        // Trigger redeploy
        $this->triggerRedeploy($projectId, $token);
    }
}
```

---

## ğŸ¨ UI/UX Standards

### **Tailwind CSS Rules**
- **ALWAYS** use Tailwind utility classes - avoid custom CSS
- **MUST** implement responsive design (`sm:`, `md:`, `lg:` breakpoints)
- **ALWAYS** use consistent spacing (`space-y-4`, `gap-4`, etc.)
- Use existing color palette from the project

### **Component Patterns**
- **MUST** include loading states for async operations
- **MUST** include error states with user-friendly messages
- **ALWAYS** implement proper accessibility (ARIA labels, keyboard navigation)
- **MUST** be responsive and mobile-friendly

---

## âš™ï¸ Environment Configuration

### **Required Environment Variables**

**Next.js (.env.local):**
```bash
# API endpoint
NEXT_PUBLIC_API_URL=http://localhost:8000

# Supabase credentials (loaded dynamically from Laravel after setup)
# These are NOT in .env - fetched from backend after connection
```

**Backend Environment Variables:**
```bash
# Vercel KV (automatically set by Vercel when you add KV storage)
KV_REST_API_URL=your_kv_rest_api_url
KV_REST_API_TOKEN=your_kv_rest_api_token

# Revalidation secret
REVALIDATE_SECRET=your-secret-key-here

# App URL (for cache invalidation)
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Supabase credentials are NOT in .env
# They are stored in Vercel KV and loaded dynamically
# After first-time setup, getSupabaseConfig() reads from KV
```

### **Dynamic Supabase Configuration**
- Supabase credentials are stored in Vercel KV during first-time setup
- Next.js API routes load credentials from KV, not `.env`
- Frontend fetches Supabase config from Next.js API endpoint

```typescript
// âœ… REQUIRED in lib/supabase-server.ts (already shown above)
export async function getSupabaseConfig(): Promise<SupabaseCredentials | null> {
  if (cachedSupabaseConfig) {
    return cachedSupabaseConfig;
  }

  const config = await kv.get<SupabaseCredentials>('supabase_config');
  if (config) {
    cachedSupabaseConfig = config;
  }
  return config;
}
```

### **First-Time Setup Flow**
```typescript
// âœ… Setup API route pattern (app/api/setup/connect/route.ts)
export async function POST(request: NextRequest) {
  try {
    const { url, anon_key, service_role_key } = await request.json();

    // 1. Validate input
    if (!url || !anon_key || !service_role_key) {
      return NextResponse.json(
        { error: 'Missing Supabase credentials' },
        { status: 400 }
      );
    }

    // 2. Validate connection by testing service role client
    const testClient = createClient(url, service_role_key);
    const { error: testError } = await testClient
      .from('pg_tables')
      .select('tablename')
      .limit(1);
    
    if (testError) {
      return NextResponse.json(
        { error: 'Invalid Supabase credentials' },
        { status: 400 }
      );
    }

    // 3. Store credentials in Vercel KV
    await kv.set('supabase_config', { url, anon_key, service_role_key });

    // 4. Run migrations on user's Supabase (optional - can be separate step)
    // await migrationService.runMigrations();

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Setup error:', error);
    return NextResponse.json(
      { error: error.message || 'Setup failed' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ“Š State Management (Zustand)

### **Store Patterns**
- **ALWAYS** use proper TypeScript interfaces for store state
- **NEVER** mutate state directly - use set() function
- **MUST** implement proper error handling in store actions

```typescript
// âœ… REQUIRED PATTERN
interface AuthState {
  user: User | null;
  loading: boolean;
  error: string | null;
  login: (credentials: LoginCredentials) => Promise<void>;
}

const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  loading: false,
  error: null,
  login: async (credentials) => {
    set({ loading: true, error: null });
    try {
      const user = await authApi.login(credentials);
      set({ user, loading: false });
    } catch (error) {
      set({ error: getErrorMessage(error), loading: false });
    }
  }
}));
```

---

## ğŸ” Security Requirements

### **Input Validation**
- **ALWAYS** validate all user inputs on both frontend and backend
- **MUST** sanitize data before database storage
- **ALWAYS** use Laravel's validation rules

### **Authentication**
- **MUST** use Supabase Auth for user authentication
- **MUST** validate Supabase JWT tokens in Laravel for protected routes
- **ALWAYS** check user permissions using Laravel Policies
- **NEVER** trust frontend-only validation
- **ONLY `/ycode` routes require authentication** - all other routes are public

---

## ğŸš¨ Critical Rules

### **Database Architecture**
1. **NEVER** store application data in Vercel KV - ONLY Supabase credentials
2. **ALWAYS** store sensitive credentials securely in Vercel KV
3. **MUST** handle case where Supabase is not configured yet
4. **NEVER** hardcode Supabase credentials in `.env` files
5. **ALWAYS** load Supabase config dynamically from Vercel KV

### **First-Time Setup**
1. **MUST** validate Supabase credentials before storing
2. **MUST** run all migrations on user's Supabase during setup
3. **ALWAYS** create first admin user in Supabase Auth
4. **MUST** handle setup errors gracefully with user-friendly messages
5. **NEVER** allow access to builder without Supabase connection

### **Page Rendering & Versioning**
1. **ALWAYS** render published version on public routes, draft in editor
2. **MUST** handle missing pages gracefully (404)
3. **NEVER** show draft versions to unauthenticated users
4. **ALWAYS** sanitize user-generated content and Tailwind classes
5. **MUST** debounce autosave to avoid excessive DB writes

### **Error Handling**
1. **ALWAYS** implement try-catch blocks for async operations
2. **MUST** provide user-friendly error messages
3. **ALWAYS** include loading states for UI components
4. **MUST** handle network failures gracefully

### **Type Safety**
1. **NEVER** use `any` type in TypeScript
2. **ALWAYS** define proper interfaces for API responses
3. **MUST** handle undefined/null values explicitly
4. **ALWAYS** use proper PHP type hints and return types

### **Performance**
1. **MUST** use React.memo for expensive components
2. **ALWAYS** implement proper useCallback/useMemo usage
3. **MUST** optimize images with Next.js Image component when possible
4. **ALWAYS** implement pagination for large data sets

---

## ğŸ“‹ Code Review Checklist

Before completing any task, ensure:

- [ ] **Formatting**: Run `npm run lint` and `npm run type-check`
- [ ] **TypeScript**: No `any` types, proper interfaces defined
- [ ] **Database Architecture**: Vercel KV for credentials only, Supabase for app data
- [ ] **Setup Flow**: First-time setup handles all edge cases gracefully
- [ ] **Credentials**: Sensitive data stored in Vercel KV, never in `.env`
- [ ] **Page Rendering**: Published pages display correctly, unpublished pages return 404
- [ ] **Error handling**: Try-catch blocks and user-friendly errors
- [ ] **Loading states**: Proper loading/error UI states
- [ ] **Responsive**: Works on mobile and desktop
- [ ] **Validation**: Both frontend and backend validation
- [ ] **Performance**: Optimized with proper React hooks
- [ ] **Security**: Input sanitization and Supabase Auth validation
- [ ] **Builder UX**: Visual builder provides good editing experience
- [ ] **Supabase**: Using Repository pattern, not direct Supabase calls in Services
- [ ] **Authentication**: Only `/ycode` routes protected, all others public
- [ ] **Migrations**: Supabase migrations run correctly during setup
- [ ] **Consistency**: Follows existing code patterns
- [ ] **Linting**: No ESLint or Pint errors

---

## ğŸ› ï¸ Development Workflow

### **When Modifying Existing Code**
1. **ALWAYS** read the existing file completely first
2. **MUST** maintain existing patterns and conventions
3. **NEVER** break existing functionality
4. **ALWAYS** test on both public pages and builder interface

### **When Creating New Components/Blocks**
1. **MUST** follow existing component structure
2. **ALWAYS** implement proper TypeScript types
3. **MUST** include loading and error states
4. **ALWAYS** make responsive and accessible
5. **MUST** be usable in both builder and public view

### **When Adding API Endpoints**
1. **MUST** add to `laravel/routes/web.php` (not api.php)
2. **ALWAYS** implement proper validation
3. **MUST** protect builder endpoints with authentication
4. **ALWAYS** return consistent JSON responses

---

## ğŸ¯ Project-Specific Patterns

### **Layer Rendering Pattern**
```typescript
// âœ… Recursive layer renderer
interface LayerRendererProps {
  layers: Layer[];
  onLayerClick?: (layerId: string) => void;
}

const LayerRenderer: React.FC<LayerRendererProps> = ({ layers, onLayerClick }) => {
  return (
    <>
      {layers.map(layer => (
        <div
          key={layer.id}
          className={layer.classes}
          onClick={() => onLayerClick?.(layer.id)}
          data-layer-id={layer.id}
        >
          {layer.type === 'text' && layer.content}
          {layer.type === 'heading' && <h1>{layer.content}</h1>}
          {layer.type === 'image' && <img src={layer.src} alt="" />}
          
          {layer.children && (
            <LayerRenderer layers={layer.children} onLayerClick={onLayerClick} />
          )}
        </div>
      ))}
    </>
  );
};
```

### **Page Fetching Pattern (Public)**
```typescript
// âœ… Fetch published page version from database
export async function fetchPublishedPage(slug: string): Promise<PageVersion> {
  const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

  const response = await fetch(`${apiUrl}/api/pages/${slug}/published`, {
    method: 'GET',
    headers: { 'Content-Type': 'application/json' }
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  return response.json();
}
```

### **Autosave Pattern (Builder)**
```typescript
// âœ… Debounced autosave for draft versions
import { debounce } from 'lodash';

const useAutosave = (pageId: string) => {
  const saveDraft = async (layers: Layer[]) => {
    const token = supabase.auth.session()?.access_token;
    
    await fetch(`${apiUrl}/api/pages/${pageId}/draft`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ layers })
    });
  };

  // Debounce for 2 seconds
  const debouncedSave = useCallback(debounce(saveDraft, 2000), [pageId]);

  return { saveDraft: debouncedSave };
};
```

### **Publish Pattern**
```typescript
// âœ… Publish page and invalidate CDN cache
export async function publishPage(pageId: string, token: string): Promise<void> {
  const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

  const response = await fetch(`${apiUrl}/api/pages/${pageId}/publish`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    }
  });

  if (!response.ok) {
    throw new Error(`Failed to publish: ${response.statusText}`);
  }
  
  // Cache invalidation happens server-side
}
```

---

## âš ï¸ Common Mistakes to Avoid

1. **NEVER** store app data in Vercel KV - use Supabase for everything except credentials
2. **NEVER** hardcode Supabase credentials in `.env` files
3. **NEVER** show draft versions on public routes - only published
4. **NEVER** use `any` type in TypeScript
5. **NEVER** forget loading/error states in UI components
6. **NEVER** skip input validation on the backend
7. **NEVER** mutate Zustand state directly
8. **NEVER** use custom CSS when Tailwind classes exist
9. **NEVER** trust layer data from database without validation (XSS risk)
10. **NEVER** expose builder endpoints without authentication
11. **NEVER** use Supabase client directly in Services - use Repositories
12. **NEVER** allow builder access without Supabase connection
13. **NEVER** expose Vercel KV credentials (they're auto-managed by Vercel)
14. **NEVER** forget to invalidate CDN cache after publish
15. **NEVER** autosave without debouncing (performance issue)

---

*Follow these rules strictly. They prevent common bugs and ensure consistency across the codebase.*

