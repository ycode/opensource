# YCode Cursor AI Rules

## üéØ Project Context

**YCode** is a self-hosted visual website builder built with Next.js 15, TypeScript, Tailwind CSS, and Supabase. This is a **fast-moving team project** where multiple developers use Cursor simultaneously. Code consistency and abstraction are critical.

---

## üß† Core Philosophy: ALWAYS Think About Abstraction

Before writing any code, ask yourself:
1. **Can this logic be extracted into a reusable hook?**
2. **Does a ShadCN component already exist for this UI element?**
3. **Is this component doing too many things? Should it be split?**
4. **Can this be a pure utility function instead of component logic?**
5. **Will another team member be able to reuse this easily?**

**Golden Rule**: If you're writing the same code twice, abstract it.

---

## üé® 1. ShadCN Components (MANDATORY)

### ALWAYS Use ShadCN for UI Primitives

**Available ShadCN Components** (in `/components/ui/`):
- `Button` - All button interactions
- `Input` - Text inputs
- `Textarea` - Multi-line text
- `Label` - Form labels
- `Select` - Dropdowns
- `Tabs` - Tab navigation
- `Dropdown Menu` - Context menus
- `Popover` - Overlays
- `Tooltip` - Hover hints
- `Slider` - Range inputs
- `Badge` - Status indicators
- `Spinner` - Loading states
- `Icon` - Lucide icons (via icon.tsx)

### ‚úÖ CORRECT Usage

```typescript
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Icon } from '@/components/ui/icon';

export function SearchBar({ onSearch }: SearchBarProps) {
  const [query, setQuery] = useState('');
  
  return (
    <div className="flex gap-2">
      <Input 
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search pages..."
      />
      <Button size="sm" onClick={() => onSearch(query)}>
        <Icon name="search" />
        Search
      </Button>
    </div>
  );
}
```

### ‚ùå FORBIDDEN - Never Do This

```typescript
// ‚ùå WRONG: Custom button instead of ShadCN
export function SearchBar({ onSearch }: SearchBarProps) {
  return (
    <button className="px-4 py-2 bg-blue-500 rounded hover:bg-blue-600">
      Search
    </button>
  );
}

// ‚ùå WRONG: Custom input instead of ShadCN
<input className="border rounded px-2 py-1" />
```

### Extending ShadCN Components

If you need custom behavior, **compose** ShadCN components:

```typescript
// ‚úÖ CORRECT: Composition
import { Button } from '@/components/ui/button';
import { Icon } from '@/components/ui/icon';

interface IconButtonProps {
  icon: string;
  label: string;
  onClick: () => void;
}

export function IconButton({ icon, label, onClick }: IconButtonProps) {
  return (
    <Button size="sm" variant="secondary" onClick={onClick}>
      <Icon name={icon} />
      {label}
    </Button>
  );
}
```

---

## üèóÔ∏è 2. Component Architecture & Abstraction

### Single Responsibility Principle

Each component should do ONE thing well:

```typescript
// ‚úÖ GOOD: Small, focused components
function PageListItem({ page, onSelect, isActive }: PageListItemProps) {
  return (
    <button
      onClick={() => onSelect(page.id)}
      className={cn(
        'w-full text-left px-3 py-2 rounded',
        isActive ? 'bg-zinc-700' : 'hover:bg-zinc-800'
      )}
    >
      <Icon name="file" />
      {page.title}
    </button>
  );
}

function PageList({ pages, selectedId, onSelect }: PageListProps) {
  return (
    <div className="flex flex-col gap-1">
      {pages.map(page => (
        <PageListItem
          key={page.id}
          page={page}
          isActive={selectedId === page.id}
          onSelect={onSelect}
        />
      ))}
    </div>
  );
}

// ‚ùå BAD: Monolithic component doing everything
function PageManagement() {
  // 500 lines of code managing pages, settings, modals, etc.
}
```

### Extract Custom Hooks

Move reusable logic into custom hooks:

```typescript
// ‚úÖ GOOD: Reusable hook
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const handler = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage in component
function SearchInput() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 500);
  
  useEffect(() => {
    if (debouncedQuery) {
      performSearch(debouncedQuery);
    }
  }, [debouncedQuery]);
}
```

### Extract Utility Functions

Keep components clean by moving pure functions to `/lib`:

```typescript
// ‚úÖ GOOD: Utility in /lib/layer-utils.ts
export function findLayerById(layers: Layer[], id: string): Layer | null {
  for (const layer of layers) {
    if (layer.id === id) return layer;
    if (layer.children) {
      const found = findLayerById(layer.children, id);
      if (found) return found;
    }
  }
  return null;
}

// Usage in component
import { findLayerById } from '@/lib/layer-utils';

function LayerEditor({ layers, selectedId }: LayerEditorProps) {
  const selectedLayer = findLayerById(layers, selectedId);
  // ...
}
```

---

## üìÅ 3. File & Naming Conventions

### File Names
- **All files**: `kebab-case.tsx` (e.g., `page-settings.tsx`, `user-profile.tsx`)
- **Components**: PascalCase export matching filename
  - File: `layer-renderer.tsx` ‚Üí Export: `LayerRenderer`
- **Utilities**: camelCase functions
  - File: `layer-utils.ts` ‚Üí Export: `findLayerById`
- **Hooks**: camelCase with `use` prefix
  - File: `use-debounce.ts` ‚Üí Export: `useDebounce`

### Variable & Function Names

```typescript
// Components & Types: PascalCase
const UserProfile: React.FC<UserProfileProps> = () => {};
interface LayerProps {}
type PageStatus = 'draft' | 'published';

// Functions & Variables: camelCase
const handleClick = () => {};
const userData = fetchUser();
function formatDate(date: Date) {}

// Event Handlers: handleX pattern
const handleSubmit = () => {};
const handlePageSelect = (id: string) => {};
const handleInputChange = (e: ChangeEvent) => {};

// Boolean: isX, hasX, shouldX
const isLoading = false;
const hasChildren = layers.length > 0;
const shouldRender = isVisible && hasData;

// Constants: SCREAMING_SNAKE_CASE
const MAX_PAGE_SIZE = 100;
const API_BASE_URL = 'https://api.example.com';
const DEFAULT_LAYER_CLASSES = 'flex gap-4';
```

---

## üì¶ 4. Import Organization

**ALWAYS order imports consistently** to prevent merge conflicts:

```typescript
// 1. React/Next.js core
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { useRouter, usePathname } from 'next/navigation';
import Image from 'next/image';

// 2. External libraries (alphabetical)
import { create } from 'zustand';
import debounce from 'lodash.debounce';
import { DndContext } from '@dnd-kit/core';

// 3. ShadCN UI components (alphabetical)
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs';

// 4. Internal components (alphabetical)
import { LayerRenderer } from '@/components/layers/LayerRenderer';
import { PageSettings } from './PageSettings';
import ElementLibrary from './ElementLibrary';

// 5. Stores (alphabetical)
import { useEditorStore } from '@/stores/useEditorStore';
import { usePagesStore } from '@/stores/usePagesStore';

// 6. Utils, APIs, lib (alphabetical)
import { pagesApi } from '@/lib/api';
import { cn } from '@/lib/utils';
import { findLayerById } from '@/lib/layer-utils';

// 7. Types (always last, alphabetical)
import type { Layer, Page, PageVersion, Asset } from '@/types';
```

---

## üõ£Ô∏è 5. Path Aliases - When to Use What

### Rules:
- Use `@/` for **everything outside current directory**
- Use `./` **ONLY** for files in the **same directory**
- Use `../` **sparingly** (max 1 level up, prefer `@/`)
- **NEVER** use deep relative paths like `../../../../`

```typescript
// ‚úÖ CORRECT
import { Button } from '@/components/ui/button';
import { useEditorStore } from '@/stores/useEditorStore';
import { PageSettings } from './PageSettings'; // Same directory
import { findLayerById } from '@/lib/layer-utils';

// ‚ùå WRONG
import { Button } from '../../../components/ui/button';
import { useEditorStore } from '../../stores/useEditorStore';
```

---

## ‚öõÔ∏è 6. Server vs Client Components (Next.js 15)

### Default: Server Components
**Don't add any directive** - components are Server Components by default.

### Add `'use client'` ONLY When:
- Using React hooks (`useState`, `useEffect`, `useCallback`, etc.)
- Using event handlers (`onClick`, `onChange`, `onSubmit`)
- Using browser APIs (`window`, `localStorage`, `document`)
- Using Zustand stores
- Using client-only libraries

```typescript
// ‚úÖ Server Component (no directive)
// app/[slug]/page.tsx
export default async function Page({ params }: { params: { slug: string } }) {
  const page = await fetchPageBySlug(params.slug);
  return <LayerRenderer layers={page.layers} />;
}

// ‚úÖ Client Component (with directive)
// app/ycode/components/LayersTree.tsx
'use client';

import { useState } from 'react';

export default function LayersTree({ layers }: LayersTreeProps) {
  const [expanded, setExpanded] = useState<Set<string>>(new Set());
  // Component using hooks and state
}
```

### Keep `'use client'` Close to Leaves
Push client boundaries down the tree:

```typescript
// ‚úÖ GOOD: Server component wraps client component
// app/page.tsx (Server Component)
export default function Page() {
  return (
    <div>
      <Header /> {/* Server */}
      <InteractiveWidget /> {/* Client */}
      <Footer /> {/* Server */}
    </div>
  );
}

// ‚ùå BAD: Everything is client-side unnecessarily
'use client';

export default function Page() {
  return (
    <div>
      <Header /> {/* Unnecessarily client-side */}
      <InteractiveWidget />
      <Footer /> {/* Unnecessarily client-side */}
    </div>
  );
}
```

---

## üóÑÔ∏è 7. Repository Pattern (Backend/API)

### NEVER Use Supabase Directly in API Routes

**Architecture**: `API Route ‚Üí Repository ‚Üí Supabase Client`

```typescript
// ‚úÖ CORRECT: Use repository pattern
// app/api/pages/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getPageById, updatePage } from '@/lib/repositories/pageRepository';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const page = await getPageById(params.id);
    
    if (!page) {
      return NextResponse.json({ error: 'Page not found' }, { status: 404 });
    }
    
    return NextResponse.json({ data: page });
  } catch (error) {
    console.error('Error fetching page:', error);
    return NextResponse.json(
      { error: 'Failed to fetch page' },
      { status: 500 }
    );
  }
}

// ‚ùå WRONG: Direct Supabase in API route
import { getSupabaseAdmin } from '@/lib/supabase-server';

export async function GET(request: NextRequest, { params }) {
  const supabase = await getSupabaseAdmin();
  const { data } = await supabase.from('pages').select('*').eq('id', params.id);
  // WRONG! Use repository instead
}
```

### Create Repositories for All Data Entities

Example structure in `/lib/repositories/pageRepository.ts`:

```typescript
import { getSupabaseAdmin } from '../supabase-server';
import type { Page } from '@/types';

export async function getAllPages(): Promise<Page[]> {
  const client = await getSupabaseAdmin();
  const { data, error } = await client
    .from('pages')
    .select('*')
    .order('created_at', { ascending: false });
  
  if (error) throw new Error(`Failed to fetch pages: ${error.message}`);
  return data || [];
}

export async function getPageById(id: string): Promise<Page | null> {
  const client = await getSupabaseAdmin();
  const { data, error } = await client
    .from('pages')
    .select('*')
    .eq('id', id)
    .single();
  
  if (error && error.code !== 'PGRST116') {
    throw new Error(`Failed to fetch page: ${error.message}`);
  }
  
  return data;
}

export async function createPage(pageData: Omit<Page, 'id' | 'created_at' | 'updated_at'>): Promise<Page> {
  const client = await getSupabaseAdmin();
  const { data, error } = await client
    .from('pages')
    .insert(pageData)
    .select()
    .single();
  
  if (error) throw new Error(`Failed to create page: ${error.message}`);
  return data;
}
```

---

## üîÑ 8. API Response Format (Consistency)

### All API Routes MUST Return Consistent Format

Use the `ApiResponse<T>` type from `/types/index.ts`:

```typescript
// ‚úÖ Success response
return NextResponse.json({ 
  data: result 
}, { status: 200 });

// ‚úÖ Error response
return NextResponse.json({ 
  error: 'Descriptive error message' 
}, { status: 400 });

// ‚úÖ With optional message
return NextResponse.json({ 
  data: result,
  message: 'Page published successfully'
}, { status: 200 });
```

### Status Codes
- `200` - Success (GET, PUT)
- `201` - Created (POST)
- `204` - No Content (DELETE)
- `400` - Bad Request (validation errors)
- `404` - Not Found
- `500` - Internal Server Error

---

## ‚ö†Ô∏è 9. Error Handling & Async Operations

### ALWAYS Follow This Pattern

```typescript
// ‚úÖ REQUIRED pattern for ALL async operations
const handleAction = async () => {
  try {
    setLoading(true);
    setError(null); // Clear previous errors
    
    const result = await apiCall();
    
    // Success handling
    setData(result);
  } catch (error) {
    console.error('Context-specific message:', error);
    setError(error instanceof Error ? error.message : 'Unknown error occurred');
  } finally {
    setLoading(false); // Always runs
  }
};
```

### In Components with UI State

```typescript
function PageEditor({ pageId }: PageEditorProps) {
  const [page, setPage] = useState<Page | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const loadPage = async () => {
      try {
        setLoading(true);
        const result = await pagesApi.getById(pageId);
        setPage(result.data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load page');
      } finally {
        setLoading(false);
      }
    };
    
    loadPage();
  }, [pageId]);
  
  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!page) return null;
  
  return <div>{/* Render page */}</div>;
}
```

---

## ‚è≥ 10. Loading States (MANDATORY)

### Always Show Loading for Async Operations

```typescript
// ‚úÖ CORRECT: Loading state shown
function PageList() {
  const [pages, setPages] = useState<Page[]>([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchPages().then(setPages).finally(() => setLoading(false));
  }, []);
  
  if (loading) {
    return <Spinner />;
  }
  
  return <div>{/* Render pages */}</div>;
}

// ‚ùå WRONG: No loading state
function PageList() {
  const [pages, setPages] = useState<Page[]>([]);
  
  useEffect(() => {
    fetchPages().then(setPages);
  }, []);
  
  return <div>{/* Flashes empty state, then content */}</div>;
}
```

### Use ShadCN Spinner

```typescript
import { Spinner } from '@/components/ui/spinner';

if (loading) return <Spinner />;
if (loading) return (
  <div className="flex items-center justify-center p-8">
    <Spinner />
  </div>
);
```

---

## üîÄ 11. Conditional Rendering - Early Returns

### Prefer Early Returns Over Nested Ternaries

```typescript
// ‚úÖ GOOD: Early returns (clean, readable)
function PageEditor({ pageId }: PageEditorProps) {
  const { page, loading, error } = usePageData(pageId);
  
  if (loading) {
    return <Spinner />;
  }
  
  if (error) {
    return <ErrorMessage error={error} />;
  }
  
  if (!page) {
    return <EmptyState message="Page not found" />;
  }
  
  return (
    <div>
      <h1>{page.title}</h1>
      {/* Main content */}
    </div>
  );
}

// ‚ùå BAD: Nested ternaries (hard to read, hard to maintain)
function PageEditor({ pageId }: PageEditorProps) {
  const { page, loading, error } = usePageData(pageId);
  
  return loading ? (
    <Spinner />
  ) : error ? (
    <ErrorMessage error={error} />
  ) : !page ? (
    <EmptyState message="Page not found" />
  ) : (
    <div>
      <h1>{page.title}</h1>
      {/* Main content */}
    </div>
  );
}
```

### For Simple Conditions

Use inline ternaries for simple show/hide:

```typescript
// ‚úÖ GOOD: Simple inline conditional
<div>
  {isVisible && <Notice message="Page is published" />}
  {count > 0 ? <Badge>{count}</Badge> : null}
</div>
```

---

## üé≠ 12. State Management with Zustand

### Keep Stores Focused and Domain-Specific

```typescript
// ‚úÖ GOOD: Focused store
// stores/useEditorStore.ts
import { create } from 'zustand';

interface EditorState {
  selectedLayerId: string | null;
  currentPageId: string | null;
  isLoading: boolean;
  isSaving: boolean;
}

interface EditorActions {
  setSelectedLayerId: (id: string | null) => void;
  setCurrentPageId: (id: string | null) => void;
  setLoading: (value: boolean) => void;
  setSaving: (value: boolean) => void;
}

type EditorStore = EditorState & EditorActions;

export const useEditorStore = create<EditorStore>((set) => ({
  selectedLayerId: null,
  currentPageId: null,
  isLoading: false,
  isSaving: false,
  
  setSelectedLayerId: (id) => set({ selectedLayerId: id }),
  setCurrentPageId: (id) => set({ currentPageId: id }),
  setLoading: (value) => set({ isLoading: value }),
  setSaving: (value) => set({ isSaving: value }),
}));
```

### Use TypeScript Interfaces for Store Types

Always define separate interfaces for state and actions, then combine them.

---

## ‚ö° 13. Performance Optimization

### When to Optimize

1. **Profile First** - Don't optimize prematurely
2. **Use React DevTools Profiler** to identify slow components
3. **Optimize when you see actual performance issues**

### React.memo for Expensive Pure Components

```typescript
// ‚úÖ Use React.memo for pure components that render often
import React, { memo } from 'react';

interface LayerItemProps {
  layer: Layer;
  onSelect: (id: string) => void;
}

const LayerItem: React.FC<LayerItemProps> = memo(({ layer, onSelect }) => {
  return (
    <div onClick={() => onSelect(layer.id)}>
      {layer.name}
    </div>
  );
});
```

### useCallback for Functions Passed as Props

```typescript
// ‚úÖ useCallback prevents unnecessary re-renders
function LayersList({ layers }: LayersListProps) {
  const handleSelect = useCallback((id: string) => {
    console.log('Selected:', id);
  }, []); // Empty deps - function never changes
  
  return (
    <>
      {layers.map(layer => (
        <LayerItem key={layer.id} layer={layer} onSelect={handleSelect} />
      ))}
    </>
  );
}
```

### useMemo for Expensive Calculations

```typescript
// ‚úÖ useMemo caches expensive computations
function PageEditor({ pageId }: PageEditorProps) {
  const { draftsByPageId } = usePagesStore();
  
  // Expensive: traverse tree structure
  const layersForCurrentPage = useMemo(() => {
    if (!pageId) return [];
    const draft = draftsByPageId[pageId];
    return draft ? draft.layers : [];
  }, [pageId, draftsByPageId]);
  
  return <LayerRenderer layers={layersForCurrentPage} />;
}
```

---

## ‚ôø 14. Accessibility (A11y)

### Required for All Interactive Elements

```typescript
// ‚úÖ GOOD: Accessible button
<Button
  onClick={handleDelete}
  aria-label="Delete page"
  aria-describedby="delete-hint"
>
  <Icon name="trash" />
</Button>
<span id="delete-hint" className="sr-only">
  This action cannot be undone
</span>

// ‚ùå BAD: Not accessible
<div onClick={handleDelete}>
  <Icon name="trash" />
</div>
```

### Checklist
- ‚úÖ Use semantic HTML (`<button>` not `<div onClick>`)
- ‚úÖ Include ARIA labels for icon-only buttons
- ‚úÖ Maintain proper heading hierarchy (h1 ‚Üí h2 ‚Üí h3)
- ‚úÖ Add alt text for images
- ‚úÖ Ensure keyboard navigation works (Tab, Enter, Esc)
- ‚úÖ Test with screen reader when possible
- ‚úÖ Maintain sufficient color contrast

---

## üìù 15. Comments & Documentation

### When to Comment

```typescript
// ‚úÖ GOOD: Explain WHY, not WHAT
// Use debounce to prevent excessive API calls during typing
const debouncedSearch = useDebounce(searchQuery, 500);

// Edge case: Supabase returns error code PGRST116 for "not found"
if (error && error.code !== 'PGRST116') {
  throw error;
}

// TODO: Add pagination after 100 pages - performance degrades with large lists
const pages = await getAllPages();

// ‚ùå BAD: Obvious comments that repeat the code
// Set loading to true
setLoading(true);

// Loop through pages
pages.forEach(page => {
  // ...
});
```

### JSDoc for Public APIs

```typescript
/**
 * Recursively finds a layer by ID in a tree structure
 * @param layers - Array of layers to search
 * @param id - Unique layer ID to find
 * @returns The found layer or null if not found
 */
export function findLayerById(layers: Layer[], id: string): Layer | null {
  for (const layer of layers) {
    if (layer.id === id) return layer;
    if (layer.children) {
      const found = findLayerById(layer.children, id);
      if (found) return found;
    }
  }
  return null;
}
```

---

## üåç 16. Environment Variables

### Client vs Server

```typescript
// ‚úÖ Client-side (accessible in browser)
const apiUrl = process.env.NEXT_PUBLIC_API_URL;

// ‚úÖ Server-side ONLY (API routes, Server Components)
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// ‚ùå WRONG: Server-side var in client code
const secret = process.env.SECRET_KEY; // Undefined in browser!
```

### Rules
- Prefix with `NEXT_PUBLIC_` ONLY for client-side variables
- NEVER expose secrets/keys to the client
- Validate required env vars at startup
- Document all env vars in README or `.env.example`

---

## üß™ 17. TypeScript Standards

### NEVER Use `any`

```typescript
// ‚ùå FORBIDDEN
function handleData(data: any) {
  return data.map((item: any) => item.name);
}

// ‚úÖ CORRECT: Proper types
interface Item {
  id: string;
  name: string;
}

function handleData(data: Item[]): string[] {
  return data.map(item => item.name);
}
```

### Use Proper Interfaces

```typescript
// ‚úÖ Define clear interfaces
interface LayerProps {
  layer: Layer;
  selectedLayerId: string | null;
  onSelect: (id: string) => void;
}

const LayerItem: React.FC<LayerProps> = ({ layer, selectedLayerId, onSelect }) => {
  // Component implementation
};
```

### Type Inference

Let TypeScript infer when obvious:

```typescript
// ‚úÖ Inference is clear
const count = 5; // number
const name = 'John'; // string
const items = pages.map(p => p.id); // string[]

// ‚úÖ Explicit when needed
const [data, setData] = useState<Page | null>(null);
```

---

## ‚úÖ 18. ESLint & Code Quality

### Always Run Before Committing

```bash
npm run lint        # Check for issues
npm run lint:fix    # Auto-fix issues
npm run type-check  # Verify TypeScript
```

### Key Rules Enforced

- **Indentation**: 2 spaces
- **Quotes**: Single quotes (template literals allowed)
- **JSX**: Max 2 props per line
- **Spacing**: Spaces in object braces `{ key: value }`
- **Self-closing**: Space before `/>` (`<Button />`)
- **Brackets**: Tag-aligned closing brackets

```typescript
// ‚úÖ CORRECT formatting
const config = { name: 'YCode', version: '1.0' };

<Button
  variant="primary"
  size="lg"
  onClick={handleClick}
/>

// ‚ùå WRONG formatting
const config={name:'YCode',version:'1.0'};

<Button variant="primary" size="lg" onClick={handleClick}/>
```

---

## üö´ Common Anti-Patterns to AVOID

### 1. Not Using ShadCN Components
```typescript
// ‚ùå Creating custom button
<button className="px-4 py-2 bg-blue-500">Click</button>

// ‚úÖ Using ShadCN
<Button variant="default">Click</Button>
```

### 2. Direct Supabase in API Routes
```typescript
// ‚ùå Direct Supabase
const supabase = await getSupabaseAdmin();
await supabase.from('pages').select();

// ‚úÖ Use repository
await getAllPages();
```

### 3. Nested Ternaries
```typescript
// ‚ùå Nested ternaries
return loading ? <Spinner /> : error ? <Error /> : <Content />;

// ‚úÖ Early returns
if (loading) return <Spinner />;
if (error) return <Error />;
return <Content />;
```

### 4. Missing Loading States
```typescript
// ‚ùå No loading state
const [data, setData] = useState([]);
useEffect(() => { fetch().then(setData); }, []);
return <List data={data} />;

// ‚úÖ With loading state
const [data, setData] = useState([]);
const [loading, setLoading] = useState(true);
useEffect(() => {
  fetch().then(setData).finally(() => setLoading(false));
}, []);
if (loading) return <Spinner />;
return <List data={data} />;
```

### 5. Using `any` Type
```typescript
// ‚ùå Using any
function process(data: any) { }

// ‚úÖ Proper types
function process(data: Page[]) { }
```

### 6. Deep Relative Imports
```typescript
// ‚ùå Deep relative paths
import { Button } from '../../../../components/ui/button';

// ‚úÖ Use path alias
import { Button } from '@/components/ui/button';
```

### 7. Not Abstracting Repeated Logic
```typescript
// ‚ùå Repeated debounce logic everywhere
const [debouncedValue, setDebouncedValue] = useState(value);
useEffect(() => {
  const timer = setTimeout(() => setDebouncedValue(value), 500);
  return () => clearTimeout(timer);
}, [value]);

// ‚úÖ Extract to custom hook
const debouncedValue = useDebounce(value, 500);
```

---

## üéØ Quick Checklist Before Committing

- [ ] Using ShadCN components for all UI primitives?
- [ ] Extracted reusable logic into hooks/utils?
- [ ] Components are small and focused (single responsibility)?
- [ ] Used proper TypeScript types (no `any`)?
- [ ] Imports organized correctly?
- [ ] Using `@/` path aliases (not relative paths)?
- [ ] Loading states for all async operations?
- [ ] Error handling with try/catch/finally?
- [ ] Early returns instead of nested ternaries?
- [ ] Added `'use client'` only when needed?
- [ ] API routes use repository pattern?
- [ ] Consistent API response format?
- [ ] Event handlers named `handleX`?
- [ ] Boolean props named `isX`, `hasX`, `shouldX`?
- [ ] Run `npm run lint:fix` and `npm run type-check`?

---

## üöÄ Team Collaboration Best Practices

### For Fast-Moving Teams Using Cursor

1. **Think abstraction first** - Before coding, ask "Can I reuse something?"
2. **Use ShadCN religiously** - Never reinvent UI primitives
3. **Keep PRs small** - Small, focused changes prevent conflicts
4. **Follow naming conventions strictly** - Makes searching and refactoring easy
5. **Document complex logic** - Help your teammates understand WHY
6. **Run linters before committing** - Catch issues early
7. **Prefer composition over duplication** - DRY principle
8. **Use TypeScript properly** - Types are documentation

---

**Remember**: Consistency > Cleverness. A fast-moving team needs predictable patterns, not creative solutions.
